Sun Jul 26 11:07:42 +08 2020

[c reference documentation](https://en.cppreference.com/w/c)

Learning C for CS2100, shall learn from [GeeksForGeeks](https://www.geeksforgeeks.org/c-programming-language/#Basics) and there's also a [C syntax wiki](https://en.wikipedia.org/wiki/C_syntax)

Interestingly, [codepad](http://codepad.org/) allows us to run programs via a browser.


[also wtf is this C shennanigans](https://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviours-that-a-c-programmer-should-know-a)



- [1. Background, History and some Basics](#1-background-history-and-some-basics)
- [2. Variable Decl, Defn and Scope](#2-variable-decl-defn-and-scope)
- [questions to clarify](#questions-to-clarify)



# 1. Background, History and some Basics

* C++ is a superset of C, some programs may compile in C but not in C++

*More into the basic structure of C programs:*

* **Header file**: 
  *  file with extension .h which contains C function declarations and macro definitions to be shared between several source files.
  *  the `#` indicates the [C preprocessor](https://en.wikipedia.org/wiki/C_preprocessor) handles the inclusion (a preprocessor directive). This involves interpolating the actual code when specific lib related function calls are made(?)
  * [ double quotes vs angle brackets](https://stackoverflow.com/a/3162067): 
     *  If the filename is enclosed within double quotes, the search path is expanded to include the current source directory. Double quotes does more by looking into the current dir first for name-resolution. 
  *  [more on preprocessing and Macros](https://www.geeksforgeeks.org/interesting-facts-preprocessors-c/):
     *  macros can be defined constants or take in function-like arguments like `#define INCREMENT(x) ++x` which can be used for x of any data type (something like generics in java? tbc)
     *  bracket your function like macros nicely: 
        - `#define MULTIPLY(a, b) (a)*(b)` vs `#define MULTIPLY(a, b) a * b`
     * macros can have concatenation of tokens using `##` (token-pasting operator) e.g. `#define merge(a, b) a##b ` and can use their string literal form using `#a`
     * loads of other macro related caveats...
* **variable declaration:** 
  *  in the C program, no variable can be used without being declared. Also in a C program, the variables are to be declared before any operation in the function. 
*  **main function declaration** :
   *  [`int main(void) { /* ... */ }`](https://www.geeksforgeeks.org/difference-int-main-int-mainvoid/), where you indicate the input param type is better method signature but either works. In C, if a function signature doesn’t specify any argument, it means that the *function can be called with any number of parameters or without any parameters*. These nuances are inconsequential in C++, will just lead to a syntax error.
   *  can define as: `int main(int argc, char *argv[]) { /* ... */ }`
   *  return type will always be an int. [other main function stuff](https://www.geeksforgeeks.org/fine-write-void-main-cc/)
  
* **different compilers give different behaviours, so to standarise, we follow the style of C standard (currently C11)**: 
  * example: 
    ```c
    #include<stdio.h> 
    int main() 
    { 
        int i = 1; 
        printf("%d %d %d\n", i++, i++, i); 
        return 0; 
    } 

        // output: 
        // ========
        // 2 1 3 - using g++ 4.2.1 on Linux.i686
        // 1 2 3 - using SunStudio C++ 5.9 on Linux.i686
        // 2 1 3 - using g++ 4.2.1 on SunOS.x86pc
        // 1 2 3 - using SunStudio C++ 5.9 on SunOS.x86pc
        // 1 2 3 - using g++ 4.2.1 on SunOS.sun4u
        // 1 2 3 - using SunStudio C++ 5.9 on SunOS.sun4u
    ```

* **data-type related stuff**:
  * an `int` has width of 32 bits (1 signed + 31 bits)

* **program error signals**, as in OS-related comms b/w processes. 
    * signals(generated by kernel, handled by process) vs interrupts(generated by processor, handled by kernel).  Error signals generally causes termination of the program and a core dump file is created named core, which stores the state of the process at the moment of termination. This file can be investigated using debugger to know the cause of program termination.
* **escape sequences** 
    - entire charset is your 256 Ascii +  ESCAPE chars
    - behaviour varies based on your C compiler. 
* **line splicing:** 
    ```c
    // C program to illustrate the concept of Line splicing. 
    #include <stdio.h> 
    int main() 
    { 
        // Line Splicing\ 
        printf("Hello GFG\n"); 
        printf("welcome"); 
        return (0); 
    } 
    // o/p: welcome
    ```

* **c tokens, keywords and identifiers** 
  * *identifier* refers to name given to entities such as variables, functions, structures etc.
    * may start with an underscore
  * `const` aka literals format: `const data_type variable_name; (or) const data_type *variable_name;`
  * Strings: arrays of chars, delimited by a null value `\0` 
    ```c
    char string[20] = “geeksforgeeks”; // 20bytes of mem aldy allocated for storing that str
    char string [] = “geeksforgeeks”;  // mem allocation will be done at execution time
    ```

* example compilation: ` $ gcc –Wall filename.c –o filename` to create the executable
  * `-Wall` enables all compiler's warnings


* **stuff to fanboy about for C:**
  * It can be used for low-level programming, such as scripting for drivers and kernels and it also supports functions of high-level programming languages, such as scripting for software applications etc.
  * modular with free movement of data across functions
  * useful when working with embedded systems and their APIs


# 2. Variable Decl, Defn and Scope



# questions to clarify

1. macros in C are not exactly the same as generics in java? need to read up on generics in C
2. 
3. 